#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO:
# xclip could potentially be replaced with a Perl equivalent.
# yt-dlp invocations could leave the tty open after exiting.
# may not need fzf (although it does make things easy).
# this could use flags/args so that it can be used non-interactively

use autodie ':all';
use feature 'say';
use strict;
use warnings;

use experimental 'switch';

# Base modules.
use File::Basename;
use File::Path 'make_path';
use File::Spec::Functions 'catdir';
use IPC::Open2;
use HTTP::Tiny;

# External modules.
use IPC::System::Simple 'capturex';
use URI;

my $program_name = fileparse $0;

sub get_duration {
	my $yt_url = shift or die "get_duration needs a URL.\n";
	chomp( my $duration = capturex 'yt-dlp', '--get-duration', '--', $yt_url );
	return $duration;
}

sub get_title {
	my $yt_url = shift or die "get_title needs a URL.\n";
	chomp( my $title = capturex 'yt-dlp', '-e', '--', $yt_url );
	return $title;
}

sub copy_to_clipboard {
	my $stuff_to_copy = shift
		or die "copy_to_clipboard needs something to copy.\n";
	chomp $stuff_to_copy;

	open my $xclip_fh, '|-', 'xclip', '-selection', 'clipboard';
	print $xclip_fh $stuff_to_copy;
	close $xclip_fh;
	die "xclip: non-zero exit of $?\n" if $?;

	return length $stuff_to_copy;
}

sub fetch_response {
	my $fetch_url = shift or die "fetch_response needs a URL.\n";
	my $http = HTTP::Tiny->new( verify_SSL => 1, );
	$http->can_ssl or die "TLS is unsupported: $!\n";

	my $response = $http->get($fetch_url);
	$response->{success} or die "$response->{status} $response->{reason}";

	return $response->{content};
}

sub check_dependencies {
	open my $which_fh, '-|', qw(which --), @_;

	chomp( my @dependency_checks = <$which_fh> );

	if ( scalar @_ != scalar @dependency_checks ) {
		my $count = 0;
		for (@_) {
			die "$_ is not installed!\n"
				unless ( $dependency_checks[$count] // '' ) =~ /$_/;
			$count++;
		}
	}

	# Placing this before the comparison loop masks the real error.
	close $which_fh;

	return scalar @dependency_checks;
}

my @dependencies = qw(fzf mpv notify-send sxiv xclip yt-dlp);

my @options = (
	'copy duration',
	'copy title',
	'download audio',
	'download file',
	'download video',
	'listen',
	'print duration',
	'print title',
	'read',
	'view image',
	'watch',
	'watch (loop)',
);

chomp( my $url = shift // die "$program_name needs a URL!\n" );

$url =~ s/\Ahttp:/https:/;
$url = URI->new($url);
$url->scheme eq 'https'
	or die "$program_name only handles the 'https' scheme.\n";

check_dependencies @dependencies;

my $fzf_pid = open2( my $fzf_out, my $fzf_in, 'fzf' );
say $fzf_in join "\n", @options;
close $fzf_in;
chomp( my $option = <$fzf_out> // die "Option must be defined.\n" );
close $fzf_out;
waitpid $fzf_pid, 0;

given ($option) {
	when ('copy duration') {
		my $duration = get_duration $url;
		copy_to_clipboard $duration;
		exec 'notify-send', '--', "Copied video duration: ($duration).";
	}

	when ('copy title') {
		my $title = get_title $url;
		copy_to_clipboard $title;
		exec 'notify-send', '--', "Copied video title: ($title).";
	}

	when ('download audio') {
		exec 'tmux', 'new-window', 'yt-dlp', '-xf', 'bestaudio/best', '--',
			$url;
	}

	when ('download file') {
		chdir;

		my $content = fetch_response($url);
		my @uri_segments = $url->path_segments;
		my $host = $url->authority;

		my $dir_to_write_to = catdir( 'Downloads', $host );

		unless ( -e $dir_to_write_to ) {
			make_path($dir_to_write_to)
				or die
				"Could not create directory named '$dir_to_write_to': $!\n";
		}

		chdir $dir_to_write_to;

		open my $download_fh, '>', $uri_segments[-1];
		print $download_fh $content;
		close $download_fh;
	}

	when ('download video') {
		exec 'tmux', 'new-window', 'yt-dlp', '--', $url;
	}

	when ('listen') {
		exec 'tmux', 'new-window', 'mpv', '--no-resume-playback',
			'--no-keep-open', '--no-pause', '--no-video', '--', $url;
	}

	when ('print duration') {
		my $duration = get_duration $url;
		exec 'notify-send', '--', "Video duration: ($duration).";
	}

	when ('print title') {
		my $title = get_title $url;
		exec 'notify-send', '--', "Video title: ($title).";
	}

	when ('read') {
		my $content = fetch_response($url);
		open my $zathura_fh, '|-', 'zathura', '-';
		print $zathura_fh $content;

		close $zathura_fh;
		die "zathura: non-zero exit of $?\n" if $?;
	}

	when ('view image') { exec 'viewimg', $url; }
	when ('watch') { exec 'tmux', 'new-window', 'mpv', '--', $url; }

	when ('watch (loop)') {
		exec 'tmux', 'new-window', 'mpv', '--loop', '--', $url;
	}

	default { die "$program_name doesn't support that option.\n"; }
}
