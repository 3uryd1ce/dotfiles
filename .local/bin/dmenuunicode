#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# inspired by Luke Smith's dmenuunicode:
# https://github.com/LukeSmithxyz/voidrice/blob/master/.local/bin/dmenuunicode

# TODO:
# Add a flag to clear clipboard after a specified timeout period.

use v5.32;
use autodie qw(:all);
use open qw(:std :encoding(UTF-8));
use strict;
use warnings;

# Core modules.
use File::Basename qw(fileparse);
use File::Spec::Functions qw(catdir catfile);
use Getopt::Std;
use IPC::Open2;

# External modules.
use IPC::System::Simple qw(capturex);
use JSON::MaybeXS;

BEGIN {
	if ( $^O eq 'openbsd' ) {
		require Anthesis::OpenBSD;
		Anthesis::OpenBSD->import(qw(pledge_or_die unveil_or_die));
	}
};

our ( $opt_h, $opt_n );
my $program_name = fileparse $0;

sub usage {
	die <<EOF;
$program_name [-hn] [file]
See $program_name(1) for more details.
EOF
}

sub check_dependencies {
	my $which_output = capturex qw(which --), @_;
	$which_output = undef;
}

my @dependencies = qw(dmenu notify-send xclip);
check_dependencies @dependencies;

getopts 'hn';
usage if $opt_h;

my $notify_user = $opt_n // 0;

my $home = ( getpwuid $> )[7];
my $xdg_cache_home = $ENV{'XDG_CACHE_HOME'} // catdir $home, '.cache';
my $colors_wal = catfile $xdg_cache_home, qw(wal colors.json);

if ( $^O eq 'openbsd' ) {
	pledge_or_die(qw(stdio rpath proc exec unveil));

	my @needed_executables = capturex(qw(which -- which dmenu notify-send xclip));

	while ( my $executable = shift @needed_executables ) {
		chomp $executable;
		unveil_or_die( $executable, 'rx' );
	}

	my %unveils = map { $_, 'r' } @INC, $colors_wal, @ARGV;
	while ( my ( $path, $perms ) = each %unveils ) {
		unveil_or_die( $path, $perms );
	}

	pledge_or_die(qw(stdio rpath proc exec));
}

my ( $background, $foreground, $color3 ) = do {
	my $decoded_json;
	unless ( eval {
		my $json = do {
			local $/;
			open my $json_fh, '<', $colors_wal;
			<$json_fh>;
		};

		$decoded_json = decode_json $json;
	} )
	{
		print STDERR "Couldn't import colors from '$colors_wal': $@" if $@;
	}

	(
		$decoded_json->{'special'}{'background'} // '#040516',
		$decoded_json->{'special'}{'foreground'} // '#e0cef3',
		$decoded_json->{'colors'}{'color3'} // '#9974e7',
	);
};

#<<<
my @dmenu_options = (
	'-i',
	'-l', 20,
	'-fn', 'mono-12',
	'-nb', $background,
	'-nf', $color3,
	'-sb', $background,
	'-sf', $foreground,
);
#>>>

$ENV{'DISPLAY'} // die "$program_name requires a graphical environment";

my $dmenu_pid = open2( my $dmenu_out, my $dmenu_in, 'dmenu', @dmenu_options );
binmode $dmenu_out, 'encoding(UTF-8)';
binmode $dmenu_in, 'encoding(UTF-8)';

while ( <<>> ) {
	my $emoji_and_description = ( split /;/ )[0];
	say $dmenu_in $emoji_and_description;
}

close $dmenu_in;

chomp( my $user_input = <$dmenu_out> // die "$program_name needs an emoji!\n" );
close $dmenu_out;
waitpid $dmenu_pid, 0;

# Check that the line starts with an emoji. This is both a sanity check and a
# way to prevent bogus contents from getting copied into the clipboard.
$user_input =~ /\A \p{Emoji}+ \p{Emoji_Component}* [ \t]/x
	or die "Malformed input: $user_input";

my $emoji = ( split ' ', $user_input )[0];

open my $xclip_fh, '|-', qw(xclip -i -selection clipboard);
print $xclip_fh $emoji;
close $xclip_fh;

if ($notify_user) { exec qw(notify-send --), 'Emoji copied to clipboard'; }
