#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <dev@anthes.is>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# inspired by Luke Smith's dmenuunicode:
# https://github.com/LukeSmithxyz/voidrice/blob/master/.local/bin/dmenuunicode

# TODO:
# Add a flag to clear clipboard after a specified timeout period.

use v5.36;
use autodie qw(:all);
use feature qw(unicode_strings);
use open qw(:std :encoding(UTF-8));
use utf8;
use warnings qw(FATAL utf8);

# Core modules.
use File::Basename qw(fileparse);
use File::Spec::Functions qw(catdir catfile);
use Getopt::Std;
use IPC::Open2;
use Unicode::Normalize qw(normalize);

# External modules.
use IPC::System::Simple qw(capturex);

BEGIN {
	if ( $^O eq 'openbsd' ) {
		require Anthesis::OpenBSD::Pledge;
		require Anthesis::OpenBSD::Unveil;
		Anthesis::OpenBSD::Pledge->import(qw(pledge_or_die));
		Anthesis::OpenBSD::Unveil->import(qw(unveil_or_die));
	}
}

use Anthesis::Dotfiles::Pywal qw(import_pywal_colors);

sub usage {
	my $program_name = fileparse $0;
	die <<EOF;
$program_name [-hn] [file ...]
See $program_name(1) for more details.
EOF
}

sub program_err {
	my $program_name = fileparse $0;
	die "[$program_name]: ", @_;
}

sub create_emoji_hash_ref_from_input {
	my $emoji_hash_ref;

	while ( <<>> ) {
		$_ = normalize 'D', $_;
		chomp;

		# Sanity check each line as a way to prevent bogus contents from
		# getting copied into the clipboard.
		m/
		\A

		\p{Emoji}+
		\p{Emoji_Component}*

		\p{Space_Separator}+

		(
		\p{Lowercase_Letter} |
		\p{Uppercase_Letter} |
		\p{Decimal_Number} |
		\p{Space_Separator} |
		\p{Nonspacing_Mark} |
		\p{Punct} |
		)+
		;

		\p{Space_Separator}+

		(
		\p{Space_Separator}*
		\p{ASCII_Hex_Digit}+
		)+
		;

		\z
		/xn or program_err 'Malformed input, see emoji(5)';

		my $emoji_and_description = ( split /;/ )[0];
		$emoji_and_description = normalize 'C', $emoji_and_description;

		$emoji_hash_ref->{$emoji_and_description}++;
	}

	return $emoji_hash_ref;
}

our ( $opt_h, $opt_n );
getopts 'hn';
usage if $opt_h;
$opt_n = $opt_n // 0;

$ENV{'DISPLAY'} // program_err "DISPLAY variable must be defined.\n";

# We shouldn't depend on Pywal, but this variable does need to be
# declared in a broader scope (for unveil + potentially importing Pywal
# colors later).
my $wal_colors_file = do {
	my $home = ( getpwuid $> )[7];
	my $xdg_cache_home = $ENV{'XDG_CACHE_HOME'} // catdir $home, '.cache';
	catfile $xdg_cache_home, qw(wal colors);
};

PLEDGE_AND_UNVEIL: {
	## Leave this outside of the OpenBSD conditional since we are
	# implicitly checking dependencies here.
	my @needed_executables = do {
		my @execs = qw(dmenu xclip);
		if ($opt_n) {
			push @execs, 'notify-send';
		}
		capturex qw(which --), @execs;
	};

	if ( $^O eq 'openbsd' ) {
		## Not much point in unveiling if the user can supply an arbitrary file.
		if ( !@ARGV ) {
			while ( my $executable = shift @needed_executables ) {
				chomp $executable;
				unveil_or_die $executable, 'rx';
			}

			my %unveils = map { $_, 'r' } $wal_colors_file, @INC;
			while ( my ( $path, $perms ) = each %unveils ) {
				unveil_or_die $path, $perms;
			}
		}
		pledge_or_die qw(stdio rpath proc exec);
	}
}

SELECT_AND_COPY_EMOJI: {
	my @dmenu_options = qw(-i -l 20 -fn mono-12);

	eval {
		my $colors_hash_ref = import_pywal_colors $wal_colors_file;

		#<<<
		push @dmenu_options,
		(
			'-nb', $colors_hash_ref->{background},
			'-nf', $colors_hash_ref->{color3},
			'-sb', $colors_hash_ref->{background},
			'-sf', $colors_hash_ref->{foreground},
		);
		#>>>
	};
	warn $@ if $@;

	my $emoji_hash_ref = &create_emoji_hash_ref_from_input;

	my $dmenu_pid = open2 my $dmenu_out, my $dmenu_in, 'dmenu', @dmenu_options;
	binmode $dmenu_out, 'encoding(UTF-8)';
	binmode $dmenu_in, 'encoding(UTF-8)';

	for my $key ( sort keys %$emoji_hash_ref ) {
		say $dmenu_in $key;
	}

	close $dmenu_in;

	chomp( my $user_input = <$dmenu_out> // program_err "needs an emoji!\n" );
	close $dmenu_out;
	waitpid $dmenu_pid, 0;

	my $emoji = ( split ' ', $user_input )[0];
	open my $xclip_fh, '|-', qw(xclip -i -selection clipboard);
	print $xclip_fh $emoji;
}

if ($opt_n) { exec qw(notify-send --), 'Emoji copied to clipboard'; }
