#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;
use autodie;
use strict;
use warnings;

use File::Basename qw(fileparse);
use File::Find;
use List::Util qw(shuffle);

# External modules.
use File::MimeInfo::Magic qw(mimetype);

sub usage {
	my $program_name = fileparse $0;
	die <<EOF;
$program_name [file_category] [directory]
EOF
}

sub return_file_categories {
	return qw(image audio video any);
}

sub return_file_extensions {
	my $file_category = shift;

	if ( $file_category eq 'image' ) {
		return qw(jpg jpeg png);
	}
	elsif ( $file_category eq 'audio' ) {
		return qw(mp3 opus flac aac ogg wav);
	}
	elsif ( $file_category eq 'video' ) {
		return qw(mkv mp4 webm);
	}
	else { return; }
}

sub return_extension_patterns {
	my $file_category = shift or return;
	return map { qr/\.$_\z/i } return_file_extensions($file_category);
}

# TODO(?): This could match specific mimetype patterns that are
# associated with a particular file extension. But it would be a lot to
# put in this program---better done as a module, and someone's probably
# already done it.
sub return_mimetype_patterns {
	my $file_category = shift or return;
	return qr{\A$file_category/};
}

sub return_file_properties_hash {
	my $file_category = shift or return;
	my %file_properties_hash = ();

	$file_properties_hash{$file_category}{extensions} =
		[ return_file_extensions($file_category) ];

	$file_properties_hash{$file_category}{extension_patterns} =
		[ return_extension_patterns($file_category) ];

	$file_properties_hash{$file_category}{mimetype_patterns} =
		[ return_mimetype_patterns($file_category) ];

	return %file_properties_hash;
}

sub program_sanity_checks {
	my $file_category = shift or return;
	my $directory = shift or return;

	-e $directory or die "'$directory' doesn't exist.\n";
	-d _ or die "'$directory' isn't a directory.\n";

	if ( !grep { $_ eq $file_category } &return_file_categories ) {
		my $file_category_output = join( "\n", &return_file_categories );

		die <<EOF;
Supported file categories:
$file_category_output
EOF
	}
}

my $provided_file_category = shift or usage;
my $provided_directory = shift or usage;

program_sanity_checks( $provided_file_category, $provided_directory );

my %wanted_files;
my %file_properties = &return_file_properties_hash($provided_file_category);

if ( $provided_file_category eq 'any' ) {
	find(
		sub {
			-f or return;
			++$wanted_files{$File::Find::name};
		},
		$provided_directory,
	);
}
else {
	find(
		sub {
			grep { $File::Find::name =~ $_ }
				#<<<
				@{ $file_properties{$provided_file_category}{extension_patterns} }
				#>>>
				or return;

			# Checking MIME type means we already know it's a file, so
			# -f can be skipped.
			grep { mimetype($File::Find::name) =~ $_ }
				#<<<
				@{ $file_properties{$provided_file_category}{mimetype_patterns} }
				#>>>
				or return;

			++$wanted_files{$File::Find::name};
		},
		$provided_directory,
	);
}

if (%wanted_files) {
	say join( "\n", shuffle keys %wanted_files );
}
