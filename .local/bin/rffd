#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.32;
use autodie;
use strict;
use warnings;

use experimental qw(switch);

use File::Basename qw(fileparse);
use File::Find;
use List::Util qw(shuffle);

# External modules.
use File::MimeInfo::Magic qw(mimetype);

sub usage {
	my $program_name = fileparse $0;
	die <<EOF;
$program_name [filetype] [directory]

filetype can be:
audio - mp3, opus, flac, aac, ogg, wav
video - webm, mp4, mkv
image - jpg, jpeg, png
any - matches all files
EOF
}

my $filetype_to_look_for = shift or usage;
my $directory_to_search_in = shift or usage;

-e $directory_to_search_in or die "'$directory_to_search_in' doesn't exist.\n";
-d _ or die "'$directory_to_search_in' isn't a directory.\n";

my @wanted_files;

# Takes a subroutine. Returns a closure that will call the subroutine.
#
# https://www.perlmonks.org/?node_id=109068
#
# NOTE: Still not sure if this is the best way to handle different
# callback subroutines for File::Find, but it's a lot better than
# checking the filetype on every invocation.
sub make_wanted {
	my $sub = shift;
	return sub { $sub->(); };
}

sub randaudio {
	return unless /\.(?:mp3|opus|flac|aac|ogg|wav)\z/;
	return unless mimetype($_) =~ m{\Aaudio/};

	push @wanted_files, $File::Find::name;
}

sub randvids {
	return unless /\.(?:mkv|mp4|webm)\z/;
	return unless mimetype($_) =~ m{\Avideo/};

	push @wanted_files, $File::Find::name;
}

sub randpics {
	return unless /\.(?:jpe?g|png)\z/;
	return unless mimetype($_) =~ m{\Aimage/};

	push @wanted_files, $File::Find::name;
}

sub randfiles {
	return unless -f;
	push @wanted_files, $File::Find::name;
}

given ($filetype_to_look_for) {
	when ('audio') {
		find( make_wanted( \&randaudio ), $directory_to_search_in )
	}
	when ('video') {
		find( make_wanted( \&randvids ), $directory_to_search_in )
	}
	when ('image') {
		find( make_wanted( \&randpics ), $directory_to_search_in )
	}
	when ('any') {
		find( make_wanted( \&randfiles ), $directory_to_search_in )
	}
	default {
		die "'$filetype_to_look_for' isn't a supported filetype.\n" ;
	}
}

if (@wanted_files) {
	say join( "\n", shuffle @wanted_files );
}
