#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;
use autodie;
use strict;
use warnings;

use File::Basename qw(fileparse);
use File::Find;
use List::Util qw(first shuffle);

# External modules.
use File::MimeInfo::Magic qw(mimetype);

BEGIN {
	if ( $^O eq 'openbsd' ) {
		require Anthesis::OpenBSD::Pledge;
		Anthesis::OpenBSD::Pledge->import(qw(pledge_or_die));
	}
};

pledge_or_die(qw(rpath)) if $^O eq 'openbsd';

sub usage {
	my $program_name = fileparse $0;
	die <<EOF;
$program_name [file_category] [directory]
EOF
}

sub return_file_categories {
	return qw(image audio video any);
}

sub return_file_extensions {
	my $file_category = shift;

	if ( $file_category eq 'image' ) {
		return qw(jpg jpeg png);
	}
	elsif ( $file_category eq 'audio' ) {
		return qw(mp3 opus flac aac ogg wav);
	}
	elsif ( $file_category eq 'video' ) {
		return qw(mkv mp4 webm);
	}
	else { return; }
}

sub return_extension_patterns {
	my $file_category = shift or return;
	return map { qr/\.$_\z/i } return_file_extensions $file_category;
}

# TODO(?): This could match specific mimetype patterns that are
# associated with a particular file extension. But it would be a lot to
# put in this program---better done as a module, and someone's probably
# already done it.
sub return_mimetype_patterns {
	my $file_category = shift or return;
	return qr{\A$file_category/};
}

sub return_file_properties_hash {
	my $file_category = shift or return;
	my %file_properties_hash;

	$file_properties_hash{$file_category}{extensions} =
		[ return_file_extensions $file_category ];

	$file_properties_hash{$file_category}{extension_patterns} =
		[ return_extension_patterns $file_category ];

	$file_properties_hash{$file_category}{mimetype_patterns} =
		[ return_mimetype_patterns $file_category ];

	return %file_properties_hash;
}

sub gather_every_file {
	my %wanted_files;

	return (
		sub {
			-f or return;
			++$wanted_files{$File::Find::name};
		},
		sub {
			return %wanted_files;
		},
	);
}

sub gather_type_of_file {
	my $file_category = shift or return;
	my $file_properties_ref = shift or return;
	my %wanted_files;

	return (
		sub {
			first { $File::Find::name =~ $_ }
				@{ $file_properties_ref->{$file_category}{extension_patterns} }
				or return;

			# Checking MIME type means we already know it's a file, so
			# -f can be skipped.
			first { mimetype($File::Find::name) =~ $_ }
				@{ $file_properties_ref->{$file_category}{mimetype_patterns} }
				or return;

			++$wanted_files{$File::Find::name};
		},
		sub {
			return %wanted_files;
		},
	);
}

sub program_sanity_checks {
	my $file_category = shift or return;
	my $directory = shift or return;

	-e $directory or die "'$directory' doesn't exist.\n";
	-d _ or die "'$directory' isn't a directory.\n";

	if ( !first { $_ eq $file_category } &return_file_categories ) {
		my $file_category_output = join( "\n", &return_file_categories );

		die <<EOF;
Supported file categories:
$file_category_output
EOF
	}
}

my $provided_file_category = shift or usage;
my $provided_directory = shift or usage;

program_sanity_checks $provided_file_category, $provided_directory;

my %file_properties = return_file_properties_hash $provided_file_category;

my ( $gather, $yield ) =
	( $provided_file_category eq 'any' )
	? gather_every_file()
	: gather_type_of_file( $provided_file_category, \%file_properties );

find( $gather, $provided_directory );
my %wanted_files = $yield->();

if (%wanted_files) {
	say join( "\n", shuffle keys %wanted_files );
}
