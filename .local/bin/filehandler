#!/usr/bin/env sh
# shellcheck disable=SC1090,SC2034
set -e
# Copyright (c) 2020-2021 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# check that the library file is readable. if it is, source it so its
# functions are available. if not, exit due to potentially unpredictable
# behavior.
readonly library="${HOME}/.local/bin/common.sh"
if [ -r "${library}" ]; then
  . "${library}"
else
  cat >&2 <<EOF
${library} doesn't exist or isn't readable.
${0##*/} may not function correctly without it; exiting for safety.
EOF
  exit 1
fi

usage() {
  cat >&2 <<EOF
${0##*/} requires ${args_needed} argument(s).

usage:
${0##*/} [options] [file]

options:
-h: help
-m: move file (operation)
-n: rename file (operation)

If invoked without any options, ${0##*/} behaves interactively and asks
the user for an operation.

If an operation is specified, ${0##*/} skips the operation query and
moves on to the next prompt.

Note that only one operation should be specified at a time. In fact,
${0##*/} only processes the first operation it sees.
EOF
  exit 1
}

# assigns a value to ${preload_dir} based on the file's mimetype.
determine_preload_dir() {
  mimetype="$(file -ib -- "${file}")" && readonly mimetype
  case "${mimetype}" in
    # these are organized alphabetically by mimetype
    application/epub*) readonly preload_dir="${HOME}/books"  ;;
    application/pdf*)  readonly preload_dir="${HOME}/books"  ;;
    image/*)           readonly preload_dir="${HOME}/pics"   ;;
    video/*)           readonly preload_dir="${HOME}/videos" ;;
    *)                 readonly preload_dir="${HOME}"        ;;
  esac
}

# uses ${preload_dir} to display a list of directories that a given file
# can be moved to. once the user chooses a destination with dmenu, move
# the file there and send a notification.
move_file() {
  determine_preload_dir
  dest="$(
    {
      # tilde expansion with sed for readability in dmenu
      find "${preload_dir}" -type d ! \( -name '.*' -prune \) \
        | sed -- "s|${HOME}|~|g"
      echo 'exit';
    } | menu -l 10 -p "Move ${file##*/} where?"
  )"

  [ "${dest}" = 'exit' ] && exit 0
  [ -z "${dest}" ] && err "${0##*/} needs a destination."

  # reverses tilde expansion. it's reinstated in certain lines below
  # with parameter expansion in the form "~${dest##${HOME}}"
  dest="$(echo "${dest}" | sed -- "s|~|${HOME}|g")"

  if [ -d "${dest}" ] || mkdir -p -- "${dest}"; then

    if mv -- "${file}" "${dest}/${file##*/}"; then
      notify-send -- "${file##*/} moved to ~${dest##${HOME}}"
    else
      err "Failed to move ${file##*/}"
    fi

  else
    err "~${dest##${HOME}} not found nor created."
  fi
}

# once the user chooses a filename with dmenu, rename the file
# accordingly and send a notification.
#
# dmenu seems to need at least one item from STDIN to behave properly.
rename_file() {
  new_filename="$(echo 'exit' | menu -p "Rename ${file##*/} to what?")" \
    && readonly new_filename
  if [ -n "${new_filename}" ]; then
    [ "${new_filename}" = 'exit' ] && exit 0

    if mv -- "${file}" "${file%/*}/${new_filename}"; then
      notify-send -- "${file##*/} renamed to ${new_filename}"
    else
      err "Failed to rename ${file}."
    fi

  else
    err "${0##*/} needs a new name to rename ${file##*/} to."
  fi
}

# determines how to operate on the file. if nothing was assigned to
# ${operation} by getopts, the user chooses the operation with dmenu.
choose_operation() {
  if [ -z "${operation}" ]; then
    readonly options='move
rename'
    operation="$(echo "${options}" | menu -p "What to do with ${file}?")" \
      && readonly operation

    # a small delay needs to be here. without it, the subsequent menu
    # won't appear sometimes.
    sleep 0.3
  fi

  case "${operation}" in
    'move')   move_file   ;;
    'rename') rename_file ;;
    *)        usage       ;;
  esac
}

prereqs1() {
  check_grafix
  check_deps <<'EOF'
dmenu
notify-send
EOF
}

prereqs2() {
  [ "$#" = "${args_needed}" ] || usage
  import_colors
  [ -f "$1" ] || err 'Not a file or does not exist.'
}

# parse options. get the absolute pathname of the file and use that as
# the first argument for choose_operation.
main() {
  prereqs1
  readonly args_needed=1

  while getopts hmn opt; do
    case "${opt}" in
      'h') usage                                ;;
      'm') readonly operation='move' && break   ;;
      'n') readonly operation='rename' && break ;;
      *)   usage                                ;;
    esac
  done
  shift $((OPTIND - 1))

  prereqs2 "$@"

  file="$(readlink -f -- "$1")" && readonly file
  choose_operation
}

main "$@"
