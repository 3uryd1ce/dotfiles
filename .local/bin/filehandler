#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO:
# Explore a configuration file for fallback colors, preload directories,
# and so forth.
#
# The import colors process could be packaged and imported to ease
# cognitive load (I don't know how to package things yet).
#
# pledge (and maybe unveil too).

use autodie ':all';
use strict;
use warnings;

use experimental qw(smartmatch switch);
use feature 'say';

# Base modules.
use File::Basename 'fileparse';
use File::Copy qw(copy move);
use File::Find 'find';
use File::Spec::Functions qw(catdir catfile);
use IPC::Open2;

# External modules.
use File::MimeInfo::Magic;
use IPC::System::Simple;
use JSON::MaybeXS 'decode_json';

# Variables used in subroutines.
my $home = $ENV{'HOME'} // ( getpwuid $> )[7]
	or die "No home directory found!\n";
my $program_name = fileparse $0;
my @found_directories;

sub usage {
	die <<EOF;
usage: $program_name [operation] [file]

operations:
help - display help
copy - copy file
move - move file
rename - rename file
EOF
}

sub get_preload_dir {
	my $file_to_examine = shift or die "No file for get_preload_dir given.\n";
	my $mimetype = mimetype($file_to_examine);
	my $preload_dir = do {
		given ($mimetype) {
			when (m{ \A application/(?:epub|pdf) }ax) {
				catfile $home, 'books';
			}
			when (m{ \A image/.*djvu }ax) { catfile $home, 'books'; }
			when (m{ \A image/ }ax) { catfile $home, 'pics'; }
			when (m{ \A video/ }ax) { catfile $home, 'videos'; }
			default { die "$mimetype isn't a supported mimetype!"; }
		}
	};

	return ( $preload_dir, $mimetype );
}

sub wanted {
	-d && push @found_directories, $File::Find::name;
}

sub build_filetree {
	my $file_without_destination = shift
		or die "No file for build_filetree given.\n";

	my ( $preload_dir, $mimetype ) = get_preload_dir $file_without_destination;
	-e $preload_dir or die "'$preload_dir' doesn't exist.\n";
	-d _ or die "'$preload_dir' isn't a directory.\n";

	return find( { wanted => \&wanted }, $preload_dir );
}

usage unless my $operation = shift;
usage if $operation eq 'help';
usage unless my $file_path = shift;

my $xdg_cache_home = $ENV{'XDG_CACHE_HOME'} // catdir $home, '.cache';
my $colors_wal = catfile $xdg_cache_home, 'wal', 'colors.json';

my ( $background, $foreground, $color3 ) = do {
	my $decoded_json;
	unless ( eval {
		my $json = do {
			local $/;
			open my $json_fh, '<', $colors_wal;
			<$json_fh>;
		};

		$decoded_json = decode_json $json;
	} )
	{
		print STDERR "Couldn't import colors from '$colors_wal': $@" if $@;
	}

	(
		${$decoded_json}{'special'}{'background'} // '#040516',
		${$decoded_json}{'special'}{'foreground'} // '#e0cef3',
		${$decoded_json}{'colors'}{'color3'} // '#9974e7',
	);
};

#<<<
my @dmenu_options = (
	'-i',
	'-fn', 'mono-12',
	'-nb', $background,
	'-nf', $color3,
	'-sb', $background,
	'-sf', $foreground,
);
#>>>

my ( $base_file, $dirs ) = fileparse $file_path;
if ( $operation eq 'move' || $operation eq 'copy' ) {

	# Used for its side-effects (populating @found_directories).
	build_filetree $file_path;

	# To conserve space in the dmenu prompt, $home is replaced with a
	# tilde for each entry.
	my @directories_with_tildes;
	for (@found_directories) {
		s/\A$home/~/a;
		push @directories_with_tildes, $_;
	}

	@directories_with_tildes = sort @directories_with_tildes;

	my $menu_pid = open2( my $menu_out, my $menu_in, 'dmenu', '-l', 10,
		@dmenu_options, '-p', "Where should $base_file be placed?" );

	say $menu_in "exit\n", join( "\n", @directories_with_tildes );
	close $menu_in;

	chomp( my $user_input = <$menu_out> // 'exit' );
	close $menu_out;

	waitpid $menu_pid, 0;
	exit if $user_input eq 'exit';

	# Tilde reverted since we need to do some checks.
	$user_input =~ s/\A~/$home/;
	-e $user_input or die "'$user_input' doesn't exist.\n";
	-d _ or die "'$user_input' isn't a directory.\n";

	my $destination = catfile $user_input, $base_file;

	# Tilde added again to conserve space in notify-send output.
	$user_input =~ s/\A$home/~/;

	if ( $operation eq 'move' ) {
		move $file_path, $destination or die "'$base_file' not moved: $!\n";
		system 'notify-send', '--', "Moved '$base_file' to '$user_input'";
	}
	elsif ( $operation eq 'copy' ) {
		copy $file_path, $destination or die "'$base_file' not copied: $!\n";
		system 'notify-send', '--', "Copied '$base_file' to '$user_input'";
	}
}
elsif ( $operation eq 'rename' ) {
	my $menu_pid = open2( my $menu_out, my $menu_in, 'dmenu', '-l', 10,
		@dmenu_options, '-p', "Rename $base_file to what?" );

	say $menu_in "exit\n";
	close $menu_in;

	chomp( my $user_input = <$menu_out> // 'exit' );
	close $menu_out;

	waitpid $menu_pid, 0;
	exit if $user_input eq 'exit';

	rename $file_path, catfile( $dirs, $user_input );
	system 'notify-send', '--', "Renamed '$base_file' to '$user_input'";
}
else {
	die "$operation isn't a supported operation!\n";
}
