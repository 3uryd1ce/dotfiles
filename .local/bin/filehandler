#!/bin/sh
# shellcheck disable=SC1090,SC2034
# Copyright (c) 2020-2021 Ashlen <eurydice@riseup.net>

# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.

# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

set -e


err() {
  printf '%s\n' "$*" >&2
  exit 1
}


usage() {
  err "usage:
${0##*/} [options] [file]

options:
-h: help
-c: copy file (operation)
-m: move file (operation)
-n: rename file (operation)

If invoked without any options, ${0##*/} behaves interactively and asks
the user for an operation.

If an operation is specified, ${0##*/} skips the operation query and
moves on to the next prompt.

Note that only one operation should be specified at a time. In fact,
${0##*/} only processes the first operation it sees."
}


menu() {
  dmenu -i -fn 'mono-12'       \
  -nb "${background:=#040516}" \
  -nf "${color3:=#9974e7}"     \
  -sb "${background:=#040516}" \
  -sf "${foreground:=#e0cef3}" \
  "$@"
}


check_deps() {
  while read -r dependency; do

    if [ -x "$(command -v -- "${dependency}")" ]; then
      continue

    else
      err "${dependency} not found in PATH or not executable."

    fi

  done
}


import_colors_sh() {
  readonly COLORS_SH="${XDG_CACHE_HOME:=${HOME}/.cache}/wal/colors.sh"

  if ! [ -r "${COLORS_SH}" ]; then
    echo "${COLORS_SH} is not readable." >&2

  elif ! [ -f "${COLORS_SH}" ]; then
    echo "${COLORS_SH} is not a file." >&2

  # passed sanity checks, so source the file
  else
    . "${COLORS_SH}"

  fi
}


# assigns a value to ${preload_dir} based on the file's mimetype.
determine_preload_dir() {
  MIMETYPE="$(file -ib -- "${FILE}")"
  readonly MIMETYPE

  case "${MIMETYPE}" in
    # these are organized alphabetically by mimetype
    application/epub*) readonly PRELOAD_DIR="${HOME}/books"          ;;
    application/pdf*)  readonly PRELOAD_DIR="${HOME}/books"          ;;
    image/vnd.djvu)    readonly PRELOAD_DIR="${HOME}/books"          ;;
    image/*)           readonly PRELOAD_DIR="${HOME}/pics"           ;;
    video/*)           readonly PRELOAD_DIR="${HOME}/videos"         ;;
    *)                 err "No preload directory for this filetype." ;;
  esac
}


move_file() {
  if mv -- "${FILE}" "${NO_TILDE_DEST}/${FILE##*/}"; then
    notify-send -- "${FILE##*/} moved to ${TILDE_DEST}"

  else
    err "Failed to move ${FILE##*/}"

  fi
}


copy_file() {
  if cp -- "${FILE}" "${NO_TILDE_DEST}/${FILE##*/}"; then
    notify-send -- "${FILE##*/} copied to ${TILDE_DEST}"

  else
    err "Failed to copy ${FILE##*/}"

  fi
}


# uses ${preload_dir} to display a list of directories that a given file
# can be moved to. once the user chooses a destination with dmenu, move
# the file there and send a notification.
handle_dest() {
  determine_preload_dir

  # substitutes $HOME with a tilde so the list of directories in dmenu is
  # more readable.
  TILDE_DEST="$(
    { find "${PRELOAD_DIR}" -type d | sed -- "s|^${HOME}|~|g"
      echo 'exit'
    } | menu -l 10 -p "Where should ${FILE##*/} be placed?"
  )"

  readonly TILDE_DEST


  case "${TILDE_DEST}" in

    'exit')
      exit 0

      ;;

    '')
      err "${0##*/} needs a destination."

      ;;

  esac


  NO_TILDE_DEST="$(echo "${TILDE_DEST}" | sed -- "s|^~|${HOME}|g")"
  readonly NO_TILDE_DEST

  mkdir -p -- "${NO_TILDE_DEST}" || err "${TILDE_DEST} could not be created with mkdir(1)."
}


# once the user chooses a filename with dmenu, rename the file
# accordingly and send a notification.
#
# dmenu seems to need at least one item from STDIN to behave properly.
rename_file() {
  NEW_FILENAME="$(echo 'exit' | menu -p "Rename ${FILE##*/} to what?")"
  readonly NEW_FILENAME

  case "${NEW_FILENAME}" in

    'exit')
      exit 0

      ;;

    '')
      err "${0##*/} needs a new name to rename ${FILE##*/} to."

      ;;

  esac

  if mv -- "${FILE}" "${FILE%/*}/${NEW_FILENAME}"; then
    notify-send -- "${FILE##*/} renamed to ${NEW_FILENAME}"

  else
    err "Failed to rename ${FILE}."

  fi
}


[ -z "${DISPLAY}" ] && err "${0##*/} requires a graphical environment."

check_deps <<'EOF'
dmenu
notify-send
EOF

while getopts chmn opt; do

  case "${opt}" in
    'c')     readonly OPERATION='copy'; break   ;;
    'm')     readonly OPERATION='move'; break   ;;
    'n')     readonly OPERATION='rename'; break ;;
    'h'|*)   usage                              ;;
  esac

done

shift $((OPTIND - 1))

[ -z "$1" ] && usage
import_colors_sh
[ -f "$1" ] || err 'Not a file or does not exist.'

FILE="$(readlink -f -- "$1")"
readonly FILE


# if there is no operation, prompt the user to select one.
if [ -z "${OPERATION}" ]; then
  OPERATION="$(printf '%s\n' 'copy' 'move' 'rename' | menu -p "What to do with ${FILE}?")"
  readonly OPERATION

  # a small delay needs to be here. without it, the subsequent menu
  # won't appear sometimes.
  sleep 0.25
fi


case "${OPERATION}" in
  'copy')   handle_dest && copy_file ;;
  'move')   handle_dest && move_file ;;
  'rename') rename_file              ;;
  *)        usage                    ;;
esac
