#!/usr/bin/env perl
# Copyright (c) 2023 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO:
# - spectrwm bar is initially empty unlike the other script. Why?
# - man page
# - individual refresh timers
# - modular/object-oriented approach?

use v5.36;
use strict;
use warnings;
use autodie qw(:all);

use Scalar::Util qw(looks_like_number);

# External modules.
use IPC::System::Simple qw(capturex);

BEGIN {
	if ( $^O eq 'openbsd' ) {
		require Anthesis::OpenBSD::Pledge;
		require Anthesis::OpenBSD::Unveil;
		Anthesis::OpenBSD::Pledge->import(qw(pledge_or_die));
		Anthesis::OpenBSD::Unveil->import(qw(unveil_or_die));
	}
};

pledge_or_die(qw(stdio rpath proc exec unveil)) if $^O eq 'openbsd';

sub check_dependencies {
	my $which_output = capturex qw(which --), @_;
	$which_output = undef;
	return;
}

sub check_num_return_int {
	my $number = shift or return;

	if ( !looks_like_number $number ) {
		warn "$number doesn't look like a number";
		return;
	}

	return sprintf( '%d', $number );
}

sub battery_hours_and_minutes {
	my $total_battery_minutes = capturex qw(apm -m) or return;

	chomp $total_battery_minutes;
	return if $total_battery_minutes eq 'unknown';

	return (
		check_num_return_int( $total_battery_minutes / 60 ),   # hours
		check_num_return_int( $total_battery_minutes % 60 ),   # minutes
	);
}

sub adapter_status_to_string {
	my $adapter_status = check_num_return_int( capturex qw(apm -a) );

	my %adapter_status_codes = (
		0 => 'bat',
		1 => 'chr',
		2 => 'bkup',
	);

	exists $adapter_status_codes{$adapter_status}
		? return $adapter_status_codes{$adapter_status}
		: return 'unkn';
}

sub free_space_on_partition {
	my $partition = shift or return;
	my @df_output = capturex qw(df -h), $partition;

	# Return available free space in a human readable format.
	return ( split ' ', $df_output[-1] )[3];
}

sub cpu_temperature {
	my $sysctl_name = shift or return;
	my $temperature = capturex qw(sysctl -n), $sysctl_name;
	$temperature = ( split ' ', $temperature )[0];

	return check_num_return_int $temperature;
}

sub current_mpd_track {
	my @process_lines = capturex qw(ps -ax);

	# Uses the empty string to avoid problems (maybe mpd is inactive,
	# but we don't want an undef to cause a bunch of errors).
	#
	# TODO: is there a better way to suppress warnings?
	return '' if !grep { /mpd/ } @process_lines;

	my @mpc_lines = capturex qw(mpc);
	return '' if grep { /paused/i } @mpc_lines;

	my $current_track = capturex qw(mpc current);
	chomp $current_track;
	return $current_track;
}

if ( $^O eq 'openbsd' ) {
	my @needed_executables = capturex qw(which -- which apm mpc df sysctl ps);

	while ( my $executable = shift @needed_executables ) {
		chomp $executable;
		unveil_or_die( $executable, 'rx' );
	}

	my %unveils = map { $_, 'r' } @INC;
	while ( my ( $path, $perms ) = each %unveils ) {
		unveil_or_die( $path, $perms );
	}

	pledge_or_die(qw(stdio rpath proc exec));
}

my @dependencies = qw(apm mpc);
check_dependencies @dependencies;

# Battery status is unlikely to change during runtime. Set it once and
# reference it for the rest of the program's execution.
my $battery_status = check_num_return_int( capturex qw(apm -b) );

my $partition_to_monitor = '/home';
my $cpu_temperature_sysctl = 'hw.sensors.cpu0.temp0';

# Some of the weird format stuff is used by the status bar.
# See bar_format in spectrwm(1).
while (1) {
	my $status_line;

	# If the battery is present/available, add battery information to the status line.
	if ( $battery_status != 4 and $battery_status != 255 ) {
		$status_line .= adapter_status_to_string . ': ';
		my ( $battery_hours, $battery_minutes ) = battery_hours_and_minutes;
		my $battery_percent = check_num_return_int( capturex qw(apm -l) );

		# It only makes sense to display hours and minutes if the
		# battery isn't fully charged.
		if ( defined $battery_hours and defined $battery_minutes ) {
			$status_line .= "~${battery_hours}h and ${battery_minutes}m, ";
		}
		$status_line .= 'at ' . $battery_percent . '% +< ';
	}

	$status_line .=
		'temp: ' . cpu_temperature($cpu_temperature_sysctl) . ' Â°C ';

	# Center this section and use the second bar font.
	$status_line .= '+|C +@fn=1; ';
	$status_line .= current_mpd_track . ' ';

	# Right justify this section and use the first bar font.
	$status_line .= '+|R +@fn=0; ';
	$status_line .= "${partition_to_monitor}: "
		. free_space_on_partition $partition_to_monitor;

	say $status_line;

	sleep 30;
}
