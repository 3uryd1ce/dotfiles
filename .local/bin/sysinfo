#!/usr/bin/env perl
# Copyright (c) 2023 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO:
# - spectrwm bar is initially empty unlike the other script. Why?
# - individual refresh timers
# - man page
# - modular/object-oriented approach?

use v5.36;
use strict;
use warnings;
use autodie qw(:all);

use Scalar::Util qw(looks_like_number);

# External modules.
use IPC::System::Simple qw(capturex);

sub check_dependencies {
	my $which_output = capturex qw(which --), @_;
	$which_output = undef;
	return;
}

sub check_if_number {
	my $number = shift or return;

	if ( !looks_like_number $number ) {
		warn "$number doesn't look like a number";
		return;
	}

	return $number;
}

sub battery_hours_and_minutes {
	my $total_battery_minutes = capturex qw(apm -m);

	if ( defined $total_battery_minutes ) {
		## TODO: can this be a simple 'return' instead?
		return ( undef, undef ) if $total_battery_minutes eq "unknown\n";

		check_if_number $total_battery_minutes or return;
		return (
			( $total_battery_minutes / 60 ),   # hours
			( $total_battery_minutes % 60 ),   # minutes
		);
	}

	return;
}

sub battery_percent {
	my $estimated_battery_percent = capturex qw(apm -l);

	if ( defined $estimated_battery_percent ) {
		check_if_number $estimated_battery_percent or return;
		return $estimated_battery_percent;
	}

	return;
}

sub battery_status {
	my $battery_status = capturex qw(apm -b);

	if ( defined $battery_status ) {
		check_if_number $battery_status or return;
		return $battery_status;
	}

	return;
}

sub adapter_status {
	my $adapter_status = capturex qw(apm -a);

	if ( defined $adapter_status ) {
		check_if_number $adapter_status or return;
		return $adapter_status;
	}

	return;
}

sub adapter_status_to_string {
	my $adapter_status = adapter_status;

	if ( $adapter_status == 0 ) {
		return 'bat';
	}
	elsif ( $adapter_status == 1 ) {
		return 'chr';
	}
	elsif ( $adapter_status == 2 ) {
		return 'bkup';
	}
	else {
		return 'unkn';
	}
}

sub free_space_on_partition {
	my $partition = shift or return;
	my @df_output = capturex qw(df -h), $partition;

	# Return available free space in a human readable format.
	return ( split ' ', $df_output[-1] )[3];
}

sub cpu_temperature {
	my $sysctl_name = shift or return;
	my $temperature = capturex qw(sysctl -n), $sysctl_name;
	$temperature = ( split ' ', $temperature )[0];

	check_if_number $temperature or return;
	return $temperature;
}

sub current_mpd_track {
	my @process_lines = capturex qw(ps -ax);

	# Uses the empty string to avoid problems with printf (maybe mpd is
	# inactive, but we don't an undef to cause a bunch of errors).
	#
	# TODO: is there a better way to suppress warnings?
	return '' if !grep { /\b mpd \b/x } @process_lines;

	my @mpc_lines = capturex qw(mpc);
	return '' if grep { /paused/i } @mpc_lines;

	my $current_track = capturex qw(mpc current);
	chomp $current_track;
	return $current_track;
}

if ( $^O eq 'openbsd' ) {
	use OpenBSD::Pledge;
	use OpenBSD::Unveil;

	sub pledge_or_die { pledge(@_) or die "Pledge failed: $!"; }

	sub unveil_or_die {
		my $file = shift or die "Unveil failed: $!";
		my $perms = shift or die "Unveil failed: $!";
		unveil( $file, $perms ) or die "Unveil failed: $!";
	}

	pledge_or_die(qw(stdio rpath proc exec unveil));

	my @needed_executables = capturex(qw(which -- which apm mpc df sysctl ps));

	while ( my $executable = shift @needed_executables ) {
		chomp $executable;
		unveil_or_die( $executable, 'rx' );
	}

	my %unveils = map { $_, 'r' } @INC;
	while ( my ( $path, $perms ) = each %unveils ) {
		unveil_or_die( $path, $perms );
	}

	pledge_or_die(qw(stdio rpath proc exec));
}

my @dependencies = qw(apm mpc);
check_dependencies @dependencies;

# Battery status is unlikely to change during runtime. Set it once and
# reference it for the rest of the program's execution.
my $battery_status = battery_status;

my $partition_to_monitor = '/home';
my $cpu_temperature_sysctl = 'hw.sensors.cpu0.temp0';

# Some of the weird format stuff in printf is used by the status bar.
# See bar_format in spectrwm(1).
while (1) {
	if ( $battery_status == 4 or $battery_status == 255 ) {
		printf "temp: %d °C +|C +\@fn=1; %s +|R +\@fn=0; /home: %s\n",
			cpu_temperature($cpu_temperature_sysctl), current_mpd_track,
			free_space_on_partition($partition_to_monitor);
	}
	else {
		my ( $battery_hours, $battery_minutes ) = battery_hours_and_minutes;

		# It only makes sense to display hours and minutes if the
		# battery isn't fully charged.
		if ( defined $battery_hours and defined $battery_minutes ) {
			printf
				"%s: ~%dh and %dm, at %d%% +< temp: %d °C +|C +\@fn=1; %s +|R +\@fn=0; /home: %s\n",
				adapter_status_to_string, $battery_hours, $battery_minutes,
				battery_percent, cpu_temperature($cpu_temperature_sysctl),
				current_mpd_track,
				free_space_on_partition($partition_to_monitor);
		}
		else {
			printf
				"%s: at %d%% +< temp: %d °C +|C +\@fn=1; %s +|R +\@fn=0; /home: %s\n",
				adapter_status_to_string,
				battery_percent, cpu_temperature($cpu_temperature_sysctl),
				current_mpd_track,
				free_space_on_partition($partition_to_monitor);
		}
	}
	sleep 30;
}
