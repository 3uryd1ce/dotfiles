#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <dev@anthes.is>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;
use autodie qw(:all);

use English;
use File::Basename qw(fileparse);

# External.
use JSON::MaybeXS qw(decode_json);

use Anthesis::Dotfiles::HTTP qw(decompress_response gzipped_http);

BEGIN {
	if ( $OSNAME eq 'openbsd' ) {
		require OpenBSD::Pledge;
		require OpenBSD::Unveil;
		OpenBSD::Pledge->import('pledge');
		OpenBSD::Unveil->import('unveil');
	}
	else {
		sub pledge { return 1; }
		sub unveil { return 1; }
	}
}

sub pledge_or_die (@syscalls) {
	pledge @syscalls or die "Pledge failed: $OS_ERROR";
}

sub unveil_or_die (%file_perms) {
	while ( my ( $file, $file_perms ) = each %file_perms ) {
		unveil $file, $file_perms or die "Unveil failed: $OS_ERROR";
	}
}

sub make_github_api_url ( $username, $repository ) {
	return "https://api.github.com/repos/$username/$repository/releases/latest";
}

sub make_federation_api_url ($server_name) {
	return 'https://federationtester.matrix.org/api'
		. "/report?server_name=$server_name";
}

# prot_exec needed for Net::SSLeay
pledge_or_die qw(stdio rpath inet dns prot_exec unveil);

my $program_name = fileparse $PROGRAM_NAME;
my $matrix_server = shift
	or die "$program_name needs a domain name to check.\n";

my $http = gzipped_http();

my $github_api_response =
	$http->get( make_github_api_url qw(matrix-org synapse) );
$github_api_response->{success}
	or die "$github_api_response->{status} $github_api_response->{reason}";

my $federation_api_response =
	$http->get( make_federation_api_url $matrix_server );
$federation_api_response->{success}
	or die
	"$federation_api_response->{status} $federation_api_response->{reason}";

unveil_or_die map { $ARG, 'r' } @INC;
pledge_or_die qw(stdio rpath);

$github_api_response = decompress_response $github_api_response;
$federation_api_response = decompress_response $federation_api_response;

my $decoded_github_api_response = decode_json $github_api_response->{content};
chomp( my $remote_synapse_version = $decoded_github_api_response->{'name'} );

# Exclude release candidates and catch unknown release schemes.
$remote_synapse_version =~ /\A v \d+\. \d+\. \d+ \z/ax
	or die "Release version did not match expected release scheme.\n";

my $decoded_federation_api_response =
	decode_json $federation_api_response->{content};

#<<<
chomp( my $current_synapse_version =
	'v' . $decoded_federation_api_response->{'Version'}{'version'} );
#>>>

if ( $remote_synapse_version gt $current_synapse_version ) {
	say "Outdated version: $current_synapse_version";
	say "New version: $remote_synapse_version";
}
