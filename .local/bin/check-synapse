#!/usr/bin/env perl
# Copyright (c) 2022-2023 Ashlen <dev@anthes.is>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;
use autodie qw(:all);

use File::Basename qw(fileparse);

# External.
use JSON::MaybeXS qw(decode_json);

use Anthesis::Dotfiles::HTTP qw(decompress_response gzipped_http);

BEGIN {
	if ( $^O eq 'openbsd' ) {
		require Anthesis::OpenBSD::Pledge;
		require Anthesis::OpenBSD::Unveil;
		Anthesis::OpenBSD::Pledge->import(qw(pledge_or_die));
		Anthesis::OpenBSD::Unveil->import(qw(unveil_or_die));
	}
}

sub make_github_api_url {
	my $username = shift or die '$username is undefined';
	my $repository = shift or die '$repository is undefined';

	return "https://api.github.com/repos/$username/$repository/releases/latest";
}

sub make_federation_api_url {
	my $server_name = shift or die '$server_name is undefined';
	return 'https://federationtester.matrix.org/api'
		. "/report?server_name=$server_name";
}

# prot_exec needed for Net::SSLeay
if ( $^O eq 'openbsd' ) {
	pledge_or_die qw(stdio rpath inet dns prot_exec unveil);
};

my $program_name = fileparse $0;
my $matrix_server = shift
	or die "$program_name needs a domain name to check.\n";

my $http = gzipped_http();

my $github_api_response =
	$http->get( make_github_api_url qw(matrix-org synapse) );
$github_api_response->{success}
	or die "$github_api_response->{status} $github_api_response->{reason}";

my $federation_api_response =
	$http->get( make_federation_api_url $matrix_server );
$federation_api_response->{success}
	or die
	"$federation_api_response->{status} $federation_api_response->{reason}";

if ( $^O eq 'openbsd' ) {
	my %unveils = map { $_, 'r' } @INC;
	while ( my ( $path, $perms ) = each %unveils ) {
		unveil_or_die $path, $perms;
	}

	pledge_or_die qw(stdio rpath);
}

$github_api_response = decompress_response $github_api_response;
$federation_api_response = decompress_response $federation_api_response;

my $decoded_github_api_response = decode_json $github_api_response->{content};
chomp( my $remote_synapse_version = $decoded_github_api_response->{'name'} );

# Exclude release candidates and catch unknown release schemes.
$remote_synapse_version =~ /\A v \d+\. \d+\. \d+ \z/ax
	or die "Release version did not match expected release scheme.\n";

my $decoded_federation_api_response =
	decode_json $federation_api_response->{content};

#<<<
chomp( my $current_synapse_version =
	'v' . $decoded_federation_api_response->{'Version'}{'version'} );
#>>>

if ( $remote_synapse_version gt $current_synapse_version ) {
	say "Outdated version: $current_synapse_version";
	say "New version: $remote_synapse_version";
}
