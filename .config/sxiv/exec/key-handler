#!/usr/bin/env sh

# check that the library file is readable. if it is, source it so its
# functions are available. if not, exit due to potentially unpredictable
# behavior.
library="${HOME}/.local/bin/common.sh"
if [ -r "${library}" ]; then
  . "${library}"
else
  cat >&2 <<EOF
${library} doesn't exist or isn't readable.
${0##*/} may not function correctly without it; exiting for safety.
EOF
  exit 1
fi

import_colors

while read -r file; do
  case "$1" in
    # delete file
    'd')
      if [ "$(menu -p "Really delete ${file}?" <<'EOF'
Yes
No
EOF
      )" = "Yes" ]; then
        rm "${file}"
        notify-send "${file} deleted."
      fi
      ;;

    # TODO: write a shell script called 'filehandler' that handles the
    # behavior of at least 'm' and 'n'. a shell script is more flexible.
    #
    # for instance, preloading a list of directories with find + dmenu
    # to suggest based on file extension is possible in a shell script,
    # but would be messy here.
    'm')
      file="$(readlink -f "${file}")"
      picture_dirs="$(find "${HOME}/pictures" -type d)"
      dest="$(echo "${picture_dirs}" | menu -l 10 -p "Move ${file} where?")"
      if [ -n "${dest}" ] && mv "${file}" "${dest}/${file##*/}"; then
        dest="$(echo "${dest}" | sed "s|${HOME}|~|g")"
        notify-send "${file##*/} moved to ${dest}"
      fi
      ;;
    'n')
      file="$(readlink -f "${file}")"
      new_filename="$(menu -p "Rename ${file##*/} to what?")"
      [ -n "${new_filename}" ] \
        && mv "${file}" "${file%/*}/${new_filename}" \
        && notify-send "${file##*/} renamed to ${new_filename}"
      ;;
    # rotate clockwise
    'r')
      convert -rotate 90 "${file}" "${file}"
      ;;
    # rotate counter-clockwise
    'R')
      convert -rotate -90 "${file}" "${file}"
      ;;
    # horizontally invert file, aka 'flop' it
    'f')
      convert -flop "${file}" "${file}"
      ;;
    # yank the relative file path
    'y')
      printf '%s' "${file}" | yank
      notify-send "${file} copied to clipboard."
      ;;
    # yank the absolute file path
    'Y')
      file="$(readlink -f "${file}")"
      echo "${file}" | yank
      notify-send "${file} copied to clipboard."
      ;;
  esac
done
