# essentially, anything too simple to warrant its own shell script
#
# note that some of these functions use aliases. if certain behavior for
# a program is documented in a comment and the flag to enable that
# behavior isn't present, it may be in "${HOME}/.config/ksh/aliases".

# a wrapper around curl(1) that passes -x to use tor(1).
anoncurl() { curl -x socks5://127.0.0.1:9050 "$@"; }

# using torsocks(1) and ftp(1) with no auto-login or user agent, send a
# GET request to $1 and send the results to STDOUT. zathura(1) reads
# from STDIN and displays the document.
#
# $1 is a URL linking to a type of document (PDF, EPUB, etc.) that
# zathura(1) can open.
anonread() { anonftp -o - "$1" | zathura -; }

# invoke apropos(1) to match $1 against any available macro key of
# manpages that match the current machine architecture.
#
# $1 is a word/phrase to search for (phrases must be quoted).
aprv() { apr -S "$(uname -m)" any="$1"; }

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to cht.sh with $1 as
# the path and send the results to STDOUT.
#
# $1 is a program one wants to learn more about.
cht() { ftp -U 'curl' -VMo - "https://cht.sh/$1"; }

# if $1 ends in '.bak', copy $1 to an identically named file except the
# new file omits '.bak'.
#
# otherwise, copy $1 to an identically named file except the new file
# ends in '.bak'.
#
# $1 is a file.
cpbak() {
  if [ -z "${1##*.bak}" ]; then
    cp "$1" "${1%.bak}"
  else
    cp "$1" "$1.bak"
  fi
}

# choose a file in ~/.config with fzf and edit it.
econf() { fzf-launch "${EDITOR}" "${HOME}/.config"; }

# perform an A record lookup on $1 and return the IP address.
#
# $1 is a domain.
grabipv4() {
  ipv4="$(host -t A "$1")"
  echo "${ipv4##*address }"
}

# perform an AAAA record lookup on $1 and return the IPv6 address.
#
# $1 is a domain.
grabipv6() {
  ipv6="$(host -t AAAA "$1")"
  echo "${ipv6##*address }"
}

# with no auto-login, no progress meter and no verbose mode, use ftp(1)
# to send a GET request to ipinfo.io with $1 as the path. Then, send the
# results to STDOUT.
#
# $1 is an IP address. If left blank, ipinf will return results for our
# public IP.
ipinf() { ftp -VMo - "https://ipinfo.io/$1"; }

# if $1 ends in '.bak', remove '.bak' from the filename.
# otherwise, append '.bak' to the filename.
#
# $1 is a file.
mvbak() {
  if [ -z "${1##*.bak}" ]; then
    mv "$1" "${1%.bak}"
  else
    mv "$1" "$1.bak"
  fi
}

# obtains the estimated size of a package and returns it in a human
# readable format (hreadable() can be found in 'common.sh').
#
# $1 is the name of a valid package.
pkgsize() {
  size="$(pkgq -s "$1" | awk '/Size/{print $2}')"
  hreadable "${size}"
}

# use bioctl(8) to unlock an encrypted partition and attach it to
# softraid0.
#
# $1 is a chunk device.
unlockhdd() { priv bioctl -c C -l "$1" softraid0; }

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to wttr.in with $1 as
# the path. Then, send the results to STDOUT.
#
# $1 is a geographical location for weather forecasting purposes. If
# left blank, wttr will return results for the geographical location
# associated with our public IP.
wttr() { ftp -U 'curl' -VMo - "https://wttr.in/$1"; }
