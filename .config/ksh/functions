# essentially, anything too simple to warrant its own shell script
#
# note that some of these functions use aliases. if certain behavior for
# a program is documented in a comment and the flag to enable that
# behavior isn't present, it may be in "${XDG_CONFIG_HOME}/ksh/aliases".
#
# one may also use `typeset -f [function]` or `functions [function]` to
# display what aliases expand to within a function.

# a wrapper around curl(1) that passes -x to use tor(1).
anoncurl() {
  case "$@" in

    ''|'-h')
      cat >&2 <<EOF
curl(1) with tor(1).

otherwise, use it the same way you would use curl(1).
EOF

      return

      ;;

  esac

  curl -x socks5://127.0.0.1:9050 "$@"
}

# using torsocks(1) and ftp(1) with no auto-login or user agent, send a
# GET request to $1 and send the results to STDOUT. zathura(1) reads
# from STDIN and displays the document.
#
# $1 is a URL linking to a type of document (PDF, EPUB, etc.) that
# zathura(1) can open.
anonread() {
  case "$1" in

    ''|'-h')
      cat >&2 <<EOF
read PDFs with tor(1).

anonread [URL linking to an ebook]
EOF

      return

      ;;

  esac

  anonftp -o - -- "$1" | zathura -- -
}

# invoke apropos(1) to match $1 against any available macro key of
# manpages that match the current machine architecture.
#
# $1 is a word/phrase to search for (phrases must be quoted).
aprv() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
invoke apropos(1) to match the given query against any available macro
key of manpages that match the current machine architecture.

aprv [query]
EOF

      return

      ;;

  esac

  apropos -S "$(uname -m)" -- any="$1"
}

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to cht.sh with $1 as
# the path and send the results to STDOUT.
#
# $1 is a program one wants to learn more about.
cht() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
retrieve command cheat sheets from cht.sh

cht [command name]
EOF

      return

      ;;

  esac

  ftp -U 'curl' -VMo - -- "https://cht.sh/$1"
}


# if $1 ends in '.bak', copy $1 to an identically named file except the
# new file omits '.bak'.
#
# otherwise, copy $1 to an identically named file except the new file
# ends in '.bak'.
#
# $1 is a file.
cpbak() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
if the given file ends in '.bak', copy to an identically named file
except the new file omits '.bak'.

otherwise, copy the given file to an identically named file except the
new file ends in '.bak'.

cpbak [file]
EOF

      return

      ;;

  esac

  case "${1##*.bak}" in
    '') cp -- "$1" "${1%.bak}" ;;
    *)  cp -- "$1" "$1.bak"    ;;
  esac
}

# choose files with fzf and edit them.
ebin() { fzf-open "${EDITOR}" "${HOME}/.local/bin"; }
econf() { fzf-open "${EDITOR}" "${XDG_CONFIG_HOME}"; }
enotes() { fzf-open "${EDITOR}" "${HOME}/notes"; }

fzf_hist() {
  RES="$(fzf --tac --no-sort -e < "${HISTFILE}")"
  [ -n "${RES}" ] || return 0
  eval "${RES}"
}

# perform an A record lookup on $1 and return the IP address.
#
# $1 is a domain.
grabipv4() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
perform an A record lookup and return the IP address.

grabipv4 [IP address]
EOF

      return

      ;;

  esac

  dig A +short "$1"
}

# perform an AAAA record lookup on $1 and return the IPv6 address.
#
# $1 is a domain.
grabipv6() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
perform an AAAA record lookup and return the IPv6 address.

grabipv6 [IPv6 address]
EOF

      return

      ;;

  esac

  dig AAAA +short "$1"
}

# if $1 is less than 1024, print it and exit successfully.
# if $1 is not an integer, exit with an error.
# otherwise, convert $1 to its human readable counterpart.
#
# $1 is a positive integer (supporting rational numbers would require
# some additional code to handle exceptions).
#
# bug: 1024000 returns 0MB.
#
# TODO: perhaps this can use bc(1)
hreadable() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
return a human readable integer.

hreadable [positive integer]
EOF

      return

      ;;

  esac

  no_of_loops=0
  size="$1"

  # sanity check so math below works. also alleviates the need to use
  # printf(1) below since we can at least know that ${size} is an
  # integer.
  case "${size}" in
    *[!0-9]*) echo 'Only integers are accepted.' >&2; return  ;;
    *)        # size is an integer, so do nothing and proceed ;;
  esac

  # size < 1024 means the value printed should be in bytes.
  [ "${size}" -lt 1024 ] \
    && echo "${size}B" \
    && return 0

  until [ "${#size}" -le 3 ]; do
    : $((no_of_loops += 1))
    : $((size /= 1024))
  done

  case ${no_of_loops} in
    1) echo "${size}KB"                                                 ;;
    2) echo "${size}MB"                                                 ;;
    3) echo "${size}GB"                                                 ;;
    4) echo "${size}TB"                                                 ;;
    *) echo 'hreadable() can only convert up to terabytes.' >&2; return ;;
  esac
}

# with no auto-login, no progress meter and no verbose mode, use ftp(1)
# to send a GET request to ipinfo.io with $1 as the path. Then, send the
# results to STDOUT.
#
# $1 is an IP address. If left blank, ipinf will return results for our
# public IP.
ipinf() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
display IP address information from ipinfo.io

ipinf [IP address]
EOF

      return

      ;;

  esac

  ftp -VMo - -- "https://ipinfo.io/$1"
}

# journal
jrnl() {
  case "$@" in

    '') # being used as intended

      ;;

    '-h'|*)
      cat >&2 <<EOF
jrnl (for journaling) takes no arguments.

It creates ${HOME}/notes/journal/$(date '+%F').txt (including the
directory tree, if it doesn't exist) with appropriate formatting and
then opens up the file in ${EDITOR:-EDITOR}.
EOF

      return

      ;;

  esac

  today="$(date '+%F')"
  jrnl_entry="${HOME}/notes/journal/${today}.txt"

  # easier to just create the directory than error
  mkdir -p "${jrnl_entry%/*}"

  if ! [ -e "${jrnl_entry}" ]; then
    { echo
      echo "${today}"
      date '+%H:%M'
    } > "${jrnl_entry}"

  else
    { echo
      echo '-'
      date '+%H:%M'
    } >> "${jrnl_entry}"

  fi

  "${EDITOR}" "${jrnl_entry}"
}

# read a markdown document with man(1).
manmd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
read a markdown document with man(1).

manmd [markdown document]
EOF

      return

    ;;

  esac

  lowdown -T 'man' "$1" | mandoc -a
}

# if $1 ends in '.bak', remove '.bak' from the filename.
# otherwise, append '.bak' to the filename.
#
# $1 is a file.
mvbak() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
if the given file ends in '.bak', remove '.bak' from the filename.
otherwise, append '.bak' to the filename.

mvbak [file]
EOF

      return

      ;;

  esac

  case "${1##*.bak}" in
    '') mv -- "$1" "${1%.bak}" ;;
    *)  mv -- "$1" "$1.bak"    ;;
  esac
}

# checks the headers of a website with tor(1).
# nc_head [path] [domain] 80 for HTTP.
# nc_head [path] -c [domain] 443 for HTTPS.
nc_head() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
checks the headers of a website with tor(1).

HTTP:
nc_head [path] [domain] 80

HTTPS:
nc_head [path] -c [domain] 443
EOF

      return

      ;;

  esac

  path="$1"
  shift
  printf "%s\r\n\r\n" "HEAD ${path} HTTP/1.0" | nc_tor "$@"
}

# nc(1) + tor(1) = fun.
nc_tor() {
  case "$@" in

    ''|'-h')
      cat >&2 <<'EOF'
nc(1) + tor(1) = nc_tor()

otherwise, use it the same way you would use nc(1).
EOF

      return

      ;;

  esac

  nc -X 5 -x 127.0.0.1:9050 "$@"
}

# obtains the estimated size of a package and returns it in a human
# readable format.
#
# $1 is the name of a valid package.
pkgsize() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
obtains the estimated size of a package and returns it in a human
readable format.

pkgsize [package name]
EOF

      return

      ;;

  esac

  size="$(pkgq -s -- "$1" | awk -- '/Size/{print $2}')"
  hreadable "${size}"
}

# with rffd, open up random pics with sxiv(1).
randpics() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
with rffd, open up random pics with sxiv(1).

randpics [directory with pics]
EOF

      return

      ;;

  esac

  rffd -c 0 pic "$1" | tr '\n' '\0' | xargs -0 -- sxiv --
}

# with rffd, open up random videos with mpv(1).
randvids() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
with rffd, open up random videos with mpv(1).

randvids [directory with videos]
EOF

      return

      ;;

  esac

  rffd -c 0 video "$1" | tr '\n' '\0' | xargs -0 -- mpv --no-resume-playback --
}

# choose a book with fzf and read it.
readabook() { fzf-open "${READER}" "${HOME}/books"; }

# read a markdown document with less(1).
readmd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
read a markdown document with less(1).

readmd [markdown document]
EOF

      return

      ;;

  esac

  lowdown -T 'term' --term-no-colour "$1" | less
}

# usage:
#
# tarpv [archive target] > filename
tarpv() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
archive something with tar(1) and watch progress with pv(1).

without compression:
tarpv [archive target] > filename

with compression:
tarpv [archive target] | gzip -c > filename
EOF

      return

      ;;

  esac

  # command -v will match the alias
  DU="$(which 'du')"

  size_of_dir="$(
    "${DU}" -sh "$1" \
      | sed -E "s/\.([[:digit:]])+//" \
      | cut -f 1
  )"

  tar -cf - "$1" | pv -s "${size_of_dir}"
}

# test Matrix federation and output the JSON.
#
# $1 is a domain name associated with a Matrix homeserver.
testfed() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
test Matrix federation and output the JSON.

testfed [matrix homeserver domain]
EOF

    return

    ;;

  esac

  ftp -U '' -VMno - -- \
    "https://federationtester.matrix.org/api/report?server_name=$1"
}

# use bioctl(8) to unlock an encrypted partition and attach it to
# softraid0.
#
# $1 is an encrypted partition.
unlockhdd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
unlock a drive encrypted with bioctl(8).

unlockhdd [encrypted partition]
EOF

      return

      ;;

  esac

  priv bioctl -c C -l "$1" softraid0
}

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to wttr.in with $1 as
# the path. Then, send the results to STDOUT.
#
# $1 is a geographical location for weather forecasting purposes.
wttr() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
get weather information.

wttr [location]
EOF

      return

      ;;

  esac

  ftp -U 'curl' -VMo - -- "https://wttr.in/$1";
}
