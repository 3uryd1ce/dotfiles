# essentially, anything too simple to warrant its own shell script
#
# note that some of these functions use aliases. if certain behavior for
# a program is documented in a comment and the flag to enable that
# behavior isn't present, it may be in "${HOME}/.config/ksh/aliases".
#
# one may also use `typeset -f [function]` or `functions [function]` to
# display what aliases expand to within a function.

# a wrapper around curl(1) that passes -x to use tor(1).
anoncurl() {
  case "$@" in

    ''|'-h')
      cat >&2 <<EOF
curl(1) with tor(1).

otherwise, use it the same way you would use curl(1).
EOF

      return

      ;;

    *)
      curl -x socks5://127.0.0.1:9050 "$@"

      ;;

  esac
}

# using torsocks(1) and ftp(1) with no auto-login or user agent, send a
# GET request to $1 and send the results to STDOUT. zathura(1) reads
# from STDIN and displays the document.
#
# $1 is a URL linking to a type of document (PDF, EPUB, etc.) that
# zathura(1) can open.
anonread() {
  case "$1" in

    ''|'-h')
      cat >&2 <<EOF
read PDFs with tor(1).

anonread [URL linking to an ebook]
EOF

      return

      ;;

    *)
      anonftp -o - -- "$1" | zathura -- -

      ;;

  esac
}

# invoke apropos(1) to match $1 against any available macro key of
# manpages that match the current machine architecture.
#
# $1 is a word/phrase to search for (phrases must be quoted).
aprv() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
invoke apropos(1) to match the given query against any available macro
key of manpages that match the current machine architecture.

aprv [query]
EOF

      return

      ;;

    *)
      apropos -S "$(uname -m)" -- any="$1"

      ;;

  esac
}

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to cht.sh with $1 as
# the path and send the results to STDOUT.
#
# $1 is a program one wants to learn more about.
cht() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
retrieve command cheat sheets from cht.sh

cht [command name]
EOF

      return

      ;;

    *)
      ftp -U 'curl' -VMo - -- "https://cht.sh/$1"

      ;;

  esac
}


# if $1 ends in '.bak', copy $1 to an identically named file except the
# new file omits '.bak'.
#
# otherwise, copy $1 to an identically named file except the new file
# ends in '.bak'.
#
# $1 is a file.
cpbak() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
if the given file ends in '.bak', copy to an identically named file
except the new file omits '.bak'.

otherwise, copy the given file to an identically named file except the
new file ends in '.bak'.

cpbak [file]
EOF

      return

      ;;

    *)
      case "${1##*.bak}" in
        '') cp -- "$1" "${1%.bak}" ;;
        *)  cp -- "$1" "$1.bak"    ;;
      esac

      ;;

  esac
}

# choose files with fzf and edit them.
ebin() { fzf-open "${EDITOR}" "${HOME}/.local/bin"; }
econf() { fzf-open "${EDITOR}" "${HOME}/.config"; }
enotes() { fzf-open "${EDITOR}" "${HOME}/notes"; }

# perform an A record lookup on $1 and return the IP address.
#
# $1 is a domain.
grabipv4() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
perform an A record lookup and return the IP address.

grabipv4 [IP address]
EOF

      return

      ;;

    *)
      dig A +short "$1"

      ;;

  esac
}

# perform an AAAA record lookup on $1 and return the IPv6 address.
#
# $1 is a domain.
grabipv6() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
perform an AAAA record lookup and return the IPv6 address.

grabipv6 [IPv6 address]
EOF

      return

      ;;

    *)
      dig AAAA +short "$1"

      ;;

  esac
}

# if $1 is less than 1024, print it and exit successfully.
# if $1 is not an integer, exit with an error.
# otherwise, convert $1 to its human readable counterpart.
#
# $1 is a positive integer (supporting rational numbers would require
# some additional code to handle exceptions).
#
# bug: 1024000 returns 0MB. maybe fix it by checking modulus?
hreadable() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
return a human readable integer.

hreadable [positive integer]
EOF

      return

      ;;

    *)
      no_of_loops=0
      size="$1"

      ;;

  esac

  # sanity check so math below works. also alleviates the need to use
  # printf(1) below since we can at least know that ${size} is an
  # integer.
  case "${size}" in
    *[!0-9]*) echo 'Only integers are accepted.' >&2; return  ;;
    *)        # size is an integer, so do nothing and proceed ;;
  esac

  # size < 1024 means the value printed should be in bytes.
  [ "${size}" -lt 1024 ] \
    && echo "${size}B" \
    && return 0

  until [ "${#size}" -le 3 ]; do
    : $((no_of_loops += 1))
    : $((size /= 1024))
  done

  case ${no_of_loops} in
    1) echo "${size}KB"                                                 ;;
    2) echo "${size}MB"                                                 ;;
    3) echo "${size}GB"                                                 ;;
    4) echo "${size}TB"                                                 ;;
    *) echo 'hreadable() can only convert up to terabytes.' >&2; return ;;
  esac
}

# with no auto-login, no progress meter and no verbose mode, use ftp(1)
# to send a GET request to ipinfo.io with $1 as the path. Then, send the
# results to STDOUT.
#
# $1 is an IP address. If left blank, ipinf will return results for our
# public IP.
ipinf() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
display IP address information from ipinfo.io

ipinf [IP address]
EOF

      return

      ;;

    *)
      ftp -VMo - -- "https://ipinfo.io/$1"

      ;;

  esac
}

# journal
jrnl() {
  case "$@" in

    '') # being used as intended

      ;;

    '-h'|*)
      cat >&2 <<'EOF'
jrnl (for journaling) takes no arguments.
EOF

      return

      ;;

  esac

  today="$(date '+%F')"
  jrnl_entry="${HOME}/notes/journal/${today}.txt"

  # easier to just create the directory than error
  mkdir -p "${jrnl_entry%/*}"

  if ! [ -e "${jrnl_entry}" ]; then
    {
      echo
      echo "${today}"
      date '+%H:%M'
    } > "${jrnl_entry}"

  else
    {
      echo
      echo '-'
      date '+%H:%M'
    } >> "${jrnl_entry}"

  fi

  "${EDITOR}" "${jrnl_entry}"
}

# read a markdown document with man(1).
manmd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
read a markdown document with man(1).

manmd [markdown document]
EOF

      return

    ;;

    *)
      lowdown -T 'man' "$1" | mandoc -a

    ;;

  esac
}

# if $1 ends in '.bak', remove '.bak' from the filename.
# otherwise, append '.bak' to the filename.
#
# $1 is a file.
mvbak() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
if the given file ends in '.bak', remove '.bak' from the filename.
otherwise, append '.bak' to the filename.

mvbak [file]
EOF

      return

      ;;

    *)
      case "${1##*.bak}" in
        '') mv -- "$1" "${1%.bak}" ;;
        *)  mv -- "$1" "$1.bak"    ;;
      esac

      ;;

  esac
}

# checks the headers of a website with tor(1).
# nc_head [path] [domain] 80 for HTTP.
# nc_head [path] -c [domain] 443 for HTTPS.
nc_head() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
checks the headers of a website with tor(1).

HTTP:
nc_head [path] [domain] 80

HTTPS:
nc_head [path] -c [domain] 443
EOF

      return

      ;;

    *)
      path="$1"
      shift
      printf "%s\r\n\r\n" "HEAD ${path} HTTP/1.0" | nc_tor "$@"

      ;;

  esac
}

# nc(1) + tor(1) = fun.
nc_tor() {
  case "$@" in

    ''|'-h')
      cat >&2 <<'EOF'
nc(1) + tor(1) = nc_tor()

otherwise, use it the same way you would use nc(1).
EOF

      return

      ;;

    *)
      nc -X 5 -x 127.0.0.1:9050 "$@"

      ;;

  esac
}

# obtains the estimated size of a package and returns it in a human
# readable format.
#
# $1 is the name of a valid package.
pkgsize() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
obtains the estimated size of a package and returns it in a human
readable format.

pkgsize [package name]
EOF

      return

      ;;

    *)
      size="$(pkgq -s -- "$1" | awk -- '/Size/{print $2}')"
      hreadable "${size}"

      ;;

  esac
}

# with rffd, open up random pics with sxiv(1).
randpics() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
with rffd, open up random pics with sxiv(1).

randpics [directory of pics]
EOF

      return

      ;;

    *)
      rffd -c 0 pic "$1" | tr '\n' '\0' | xargs -0 -- sxiv --

      ;;

  esac
}

# with rffd, open up random videos with mpv(1).
randvids() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
with rffd, open up random videos with mpv(1).

randvids [directory of videos]
EOF

      return

      ;;

    *)
      rffd -c 0 video "$1" | tr '\n' '\0' | xargs -0 -- mpv --no-resume-playback --

      ;;

  esac
}

# choose a book with fzf and read it.
readabook() { fzf-open "${READER}" "${HOME}/books"; }

# read a markdown document with less(1).
readmd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
read a markdown document with less(1).

readmd [markdown document]
EOF

      return

      ;;

    *)
      lowdown -T 'term' --term-no-colour "$1" | less

      ;;

  esac
}

# usage:
#
# tarpv [archive target] > filename
tarpv() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
archive something with tar(1) and watch progress with pv(1).

without compression:
tarpv [archive target] > filename

with compression:
tarpv [archive target] | gzip -c > filename
EOF

      return

      ;;

    *)
      # command -v will match the alias
      DU="$(which 'du')"
      tab="$(printf '\t')"

      size_of_dir="$(
        "${DU}" -sh "$1" \
          | sed -Ee "s/( +|${tab}{2,})/${tab}/" -e "s/\.([[:digit:]])+//" \
          | cut -f 1
      )"

      tar -cf - "$1" | pv -s "${size_of_dir}"

      ;;

  esac
}

# test Matrix federation and output the JSON.
#
# $1 is a domain name associated with a Matrix homeserver.
testfed() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
test Matrix federation and output the JSON.

testfed [matrix homeserver domain]
EOF

    return

    ;;

  *)
    ftp -U '' -VMno - -- \
      "https://federationtester.matrix.org/api/report?server_name=$1"

    ;;

  esac
}

# use bioctl(8) to unlock an encrypted partition and attach it to
# softraid0.
#
# $1 is an encrypted partition.
unlockhdd() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
unlock a drive encrypted with bioctl(8).

unlockhdd [encrypted partition]
EOF

      return

      ;;

    *)
      priv bioctl -c C -l "$1" softraid0

      ;;

  esac
}

# with a user agent of 'curl', no progress meter, no auto-login, and no
# verbose mode, use ftp(1) to send a GET request to wttr.in with $1 as
# the path. Then, send the results to STDOUT.
#
# $1 is a geographical location for weather forecasting purposes.
wttr() {
  case "$1" in

    ''|'-h')
      cat >&2 <<'EOF'
get weather information.

wttr [location]
EOF

      return

      ;;

    *)
      ftp -U 'curl' -VMo - -- "https://wttr.in/$1";

      ;;

  esac
}
