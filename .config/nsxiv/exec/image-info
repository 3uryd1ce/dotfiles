#!/usr/bin/env perl

# Called by sxiv(1) whenever an image gets loaded.
# The output is displayed in sxiv's status bar.
# Arguments:
#   $1: path to image file
#   $2: image width
#   $3: image height

# TODO:
# Review Number::Bytes::Human to see exactly how it does what it does.

use v5.36;
use autodie;

use English;
use File::Basename qw(fileparse);

# External.
use Number::Bytes::Human qw(format_bytes);

BEGIN {
	if ( $OSNAME eq 'openbsd' ) {
		require OpenBSD::Pledge;
		require OpenBSD::Unveil;
		OpenBSD::Pledge->import('pledge');
		OpenBSD::Unveil->import('unveil');
	}
	else {
		sub pledge { return 1; }
		sub unveil { return 1; }
	}
}

sub pledge_or_die (@syscalls) {
	pledge @syscalls or die "Pledge failed: $OS_ERROR";
}

sub unveil_or_die (%file_perms) {
	while ( my ( $file, $file_perms ) = each %file_perms ) {
		unveil $file, $file_perms or die "Unveil failed: $OS_ERROR";
	}
}

my $filename = shift or die "Need a file name.\n";

unveil_or_die map { $ARG, 'r' } @INC, $filename;
pledge_or_die qw(rpath);

my $basename = fileparse $filename;

my $width = shift or die "Need a width.\n";
my $height = shift or die "Need a height.\n";
my $geometry = $width . 'x' . $height;

my $file_size = format_bytes( ( stat $filename )[7] );
my $separator = ' | ';

print $file_size . $separator . $geometry . $separator . $basename;
