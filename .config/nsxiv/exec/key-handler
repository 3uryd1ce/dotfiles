#!/usr/bin/env perl
# Copyright (c) 2022 Ashlen <eurydice@riseup.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO:
# Read files from STDIN into an array and act on them so execution only
# happens once (useful for moving files in bulk). On a related note,
# make 'y' and 'Y' bindings useful in this context. Renaming files in
# bulk could not happen this way (file clobbering), so that must be
# revisited as well.
#
# eval the things we don't care about succeeding/failing (filehandler?),
# or change filehandler so it doesn't send a >0 exit code when
# move/rename/copy are given empty parameters.

use v5.32;
use autodie qw(:all);
use strict;
use warnings;

use experimental qw(switch);

use File::Basename qw(fileparse);
use File::Spec::Functions qw(catdir catfile rel2abs);
use IPC::Open2;
use IPC::System::Simple;
use JSON::MaybeXS qw(decode_json);
use Image::Magick;

sub yank {
	chomp( my $stuff_to_copy = shift // die "yank needs something to copy!\n" );
	open my $xclip_fh, '|-', qw(xclip -selection clipboard);

	print $xclip_fh $stuff_to_copy;
	close $xclip_fh;
}

my $xdg_cache_home = $ENV{'XDG_CACHE_HOME'} // catdir $ENV{'HOME'}, '.cache';
my $colors_wal = catfile $xdg_cache_home, qw(wal colors.json);

my ( $background, $foreground, $color3 ) = do {
	my $decoded_json;
	unless ( eval {
		my $json = do {
			local $/;
			open my $json_fh, '<', $colors_wal;
			<$json_fh>;
		};

		$decoded_json = decode_json $json;
	} )
	{
		print STDERR "Couldn't import colors from '$colors_wal': $@" if $@;
	}

	(
		$decoded_json->{'special'}{'background'} // '#040516',
		$decoded_json->{'special'}{'foreground'} // '#e0cef3',
		$decoded_json->{'colors'}{'color3'} // '#9974e7',
	);
};

#<<<
my @dmenu_options = (
	'-i',
	'-fn', 'mono-12',
	'-nb', $background,
	'-nf', $color3,
	'-sb', $background,
	'-sf', $foreground,
);
#>>>

my $key = shift or die "Need a key.\n";

while ( my $file = <STDIN> ) {
	chomp $file;

	given ($key) {
		when ('c') { system qw(filehandler copy), $file; }

		when ('d') {
			my $menu_pid =
				open2( my $menu_out, my $menu_in, 'dmenu', @dmenu_options,
					'-p', "Really delete $file?" );

			say $menu_in join "\n", qw(Yes No);
			close $menu_in;

			chomp( my $user_response = <$menu_out> // 'No' );
			close $menu_out;
			waitpid( $menu_pid, 0 );

			if ( $user_response eq 'Yes' ) {
				unlink $file;
				system qw(notify-send --), "$file deleted!";
			}
		}

		when ('m') { system qw(filehandler move), $file; }
		when ('n') { system qw(filehandler rename), $file; }
		when ('r') {
			my $image_magick = Image::Magick->new;
			$image_magick->Read($file);
			$image_magick->Rotate(90);
			$image_magick->Write($file);
		}

		when ('R') {
			my $image_magick = Image::Magick->new;
			$image_magick->Read($file);
			$image_magick->Rotate(-90);
			$image_magick->Write($file);
		}

		when ('f') {
			my $image_magick = Image::Magick->new;
			$image_magick->Read($file);
			$image_magick->Flop();
			$image_magick->Write($file);
		}

		when ('y') {
			my $basename = fileparse $file;
			yank $basename;
			system qw(notify-send --),
				"File name ($basename) copied to clipboard.";
		}

		when ('Y') {
			my $absolute_path = rel2abs $file or die "Need an absolute path!\n";
			yank $absolute_path;
			system qw(notify-send --),
				"File path ($absolute_path) copied to clipboard.";
		}

		default { die "Key not bound!\n"; }
	}
}
